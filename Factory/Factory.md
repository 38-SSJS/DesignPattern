# Factory

# Factory Pattern이란?

팩토리 메소드 패턴에서는 **객체를 생성하기 위한 인터페이스**를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 **서브 클래스에서 결정하게 만드는 패턴**이다.

즉, 객체를 생성하는 부분과 객체를 사용하는 부분을 분리하여 객체 생성의 유연성을 높이는 디자인 패턴이라고 볼 수 있다.

# Factory Pattern의 등장 이유

객체 지향 디자인 패턴의 기본 원칙은 **확장에 있어서는 열려 있어야 하며, 수정에 있어서는 닫혀 있어야 한다**. (OCP, Open Closed Principle)

여기서 수정에 있어서 닫혀 있어야 한다는 말의 의미는 **코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경** 할 수 있어야 한다는 뜻이다.

때문에, 수정이 일어날 가능성이 큰 부분과 그렇지 않은 부분을 **분리**하는 것이 좋다.

객체는 속성과 함수가 변경, 또는 추가 될 수 있는데 이에 따라 객체의 생성을 담당하는 코드는 변경의 가능성이 높다.

**객체의 생성을 담당하는 클래스를 한 곳에서 관리하여 결합도를 줄이기 위하여** 팩토리 패턴이 나타나게 되었다.

# 결합도(의존성)란?

```javascript
class Product {
    init() {}
}

class User {
    let p = Product()
}
```

위 코드를 살펴보면 두 개의 클래스가 있다.

하나는 Product 클래스 이고, 다른 하나는 Product를 사용하는 User 클래스 이다.

이때 Product와 User의 관계를 의존 관계라고 한다. 의존의 대상인 Product 클래스가 사라지면, User 클래스는 **컴파일이 불가능해지고, 동작할 수 없게 된다**.

간단히 말해, **결합도는 한 클래스에 변경점이 얼마나 다른 클래스에 영향을 주는가**를 의미한다.

# 결합도가 높은 예시

![](https://user-images.githubusercontent.com/60229909/109417243-20959b00-7a06-11eb-96f3-a28bc25d1ab3.png)

만약, Product의 생성자가 바뀐다고 생각해보자. 그럼 이제 각각의 User 클래스에 있는 모든 Product 객체의 생성자를 변경해 주어야 한다.

# 결합도가 낮은 예시

![](https://user-images.githubusercontent.com/60229909/109417521-57b87c00-7a07-11eb-924b-252e31dbb119.png)

팩토리 클래스에서는 getInstance() 메소드를 이용하여 인스턴스를 반환한다.

이제, User 클래스 내부에서는 Product 객체를 직접 생성하지 않는다. 팩토리 클래스에 인스턴스를 요청하고, 생성된 인스턴스를 반환받으면 된다.
(객체의 생성을 위임했다고 말 할 수 있다.)

만약 Product의 생성자가 변경 된다면 Factory에 getInstance() 메소드 내부에 있는 Product 생성자만 변경 시켜주면 된다.
