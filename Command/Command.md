# Command Pattern(명령 패턴)

## 정의

객체의 행동을 캡슐화하여 나중에 실행할 수 있는 연산을 지원하는 패턴, 즉 `요청`을 객체의 형태로 캡슐화하여 실행하는 패턴이다.
명령 패턴을 사용하면 객체간의 결합도를 낮추고 확장성과 유연성을 높일 수 있다.

## 구조 및 구성요소

![Command Pattern Structure](https://refactoring.guru/images/patterns/diagrams/command/structure.png)

- Command(명령) : 모든 명령 객체가 구현해야 하는 인터페이스로, execute 메서드를 갖고 있다.
- ConcreteCommand(구체적인 명령) : Command 인터페이스를 구현한 구체적인 명령 객체로, execute 메서드에서 Receiver 객체의 메서드를 호출한다.
- Receiver(수신자) : ConcreteCommand 객체가 작용할 객체, 실제 작업을 수행한다.
- Invoker(발송자) : 명령을 실행하는 객체로, ConcreteCommand 객체를 저장하고 execute 메서드를 호출한다.
- Client : 구상 커맨드 객체들을 만들고 설정한다. 클라이언트는 수신자 인스턴스를 포함한 모든 요청 매개변수들을 커맨드의 생성자로 전달해야 하며 그렇게 만들어진 커맨드는 하나 또는 여러 발송자와 연관될 수 있다.

## 장단점

### 장점

- 요청하는 객체와 요청을 수행하는 객체를 분리(단일 책임 원칙, SRP)하여 유지보수와 확장이 용이하다.
- 요청을 대기열에 저장하고 실행할 수 있다.(지연 실행 구현 가능)
- 실행 취소 및 다시 실행 기능을 구현할 수 있다.
- 기존 코드를 변경하지 않고 새로운 명령을 추가하기 쉽다.(개방 폐쇄 원칙, OCP)
- 간단한 커맨드들의 집합을 복잡한 커맨드로 조합할 수 있다.

### 단점

- Command 클래스가 많이 늘어나 코드의 복잡도가 증가한다.

## 전략 패턴과의 차이

커맨드 패턴과 전략 패턴은 어떤 작업으로 객체를 매개변수화 하는데 사용할 수 있다는 공통점이 있어 비슷해 보일 수 있으나, 둘의 의도는 다르다.

- 커맨드 패턴을 사용하면 모든 작업을 객체로 변환할 수 있고, 작업의 매개변수들은 해당 객체의 필드들이 된다. 이 변환은 작업의 실행을 연기하고, 해당 작업을 대기열에 넣고, 커맨드들의 기록을 저장한 후 해당 커맨드들을 원격 서비스에 보내는 등의 작업을 가능하게 한다.

- 전략 패턴은 일반적으로 같은 작업을 수행하는 다양한 방법을 설명하므로 단일 콘텍스트 클래스 내에서 이러한 알고리즘들을 교환할 수 있도록 한다.
